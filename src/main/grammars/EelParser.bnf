{
	parserClass="de.vette.idea.neos.lang.eel.parser.EelParser"
	parserUtilClass="de.vette.idea.neos.lang.eel.parser.EelParserUtil"

	extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

	psiClassPrefix="Eel"
	psiImplClassSuffix="Impl"
	psiPackage="de.vette.idea.neos.lang.eel.psi"
	psiImplPackage="de.vette.idea.neos.lang.eel.psi.impl"
	elementTypeHolderClass="de.vette.idea.neos.lang.eel.psi.EelTypes"
	elementTypeClass="de.vette.idea.neos.lang.eel.psi.EelElementType"
	tokenTypeClass="de.vette.idea.neos.lang.eel.psi.EelTokenType"
}

root ::= conditional_expression

argument_list ::= EEL_LEFT_PAREN [conditional_expression] (VALUE_SEPARATOR conditional_expression) * EEL_RIGHT_PAREN {pin = 1}
method_call ::= method_name argument_list {pin=2}
offset_access ::= EEL_LEFT_BRACKET conditional_expression EEL_RIGHT_BRACKET {pin=1}

object_path ::= (composite_identifier|method_call) (EEL_DOT (method_call|composite_identifier|offset_access)) * [array_literal *]
composite_identifier ::= identifier (EEL_DOT (identifier)) * {
    implements = [ "de.vette.idea.neos.lang.eel.psi.EelReferenceElement" ]
    mixin = "de.vette.idea.neos.lang.eel.psi.impl.ext.EelCompositeIdentifierImplMixin"
}

identifier ::= EEL_IDENTIFIER
method_name ::= EEL_FUNCTION {
    implements = [ "de.vette.idea.neos.lang.eel.psi.EelReferenceElement" ]
    mixin = "de.vette.idea.neos.lang.eel.psi.impl.ext.EelMethodNameImplMixin"
}

value_string_line ::= VALUE_STRING_QUOTE value_string_line_content VALUE_STRING_QUOTE {
    pin=1
    implements = [ "de.vette.idea.neos.lang.eel.psi.EelReferenceElement" ]
    mixin = "de.vette.idea.neos.lang.eel.psi.impl.ext.EelValueStringLineImplMixin"
}

value_string_line_content ::= (VALUE_STRING | CRLF | VALUE_STRING_ESCAPED_QUOTE)*

term ::= VALUE_BOOLEAN !EEL_IDENTIFIER | VALUE_NUMBER | object_path | value_string_line

simple_expression ::= wrapped_expression | array_literal | object_literal | term | not_expression
wrapped_expression ::= EEL_LEFT_PAREN conditional_expression EEL_RIGHT_PAREN [array_literal *]
not_expression ::= EEL_NEGATION_OPERATOR simple_expression
conditional_expression ::= disjunction [IF_KEYWORD conditional_expression IF_SEPARATOR conditional_expression]
disjunction ::= conjunction (EEL_BOOLEAN_OR conjunction) *
conjunction ::= comparison (EEL_BOOLEAN_AND comparison) *
comparison ::= sum_calculation [EEL_COMPARISON_OPERATOR sum_calculation]
sum_calculation ::= prod_calculation ((EEL_ADDITION_OPERATOR|EEL_SUBTRACTION_OPERATOR) prod_calculation) *
prod_calculation ::= simple_expression ((EEL_DIVISION_OPERATOR|EEL_MODULO_OPERATOR|EEL_MULTIPLICATION_OPERATOR) simple_expression) *
array_literal ::= EEL_LEFT_BRACKET [conditional_expression] (VALUE_SEPARATOR conditional_expression) * EEL_RIGHT_BRACKET
object_literal_property ::= (value_string_line|EEL_IDENTIFIER) ':' conditional_expression
object_literal ::= EEL_OBJECT_LEFT_BRACE [object_literal_property] (VALUE_SEPARATOR object_literal_property) * EEL_OBJECT_RIGHT_BRACE
